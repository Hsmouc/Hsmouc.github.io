---
layout:     post
title:      MFC POJ2
date:       2015-11-17 21:21:08
author:     Hsmouc
summary:    MFC代码 关于颜色选择对话框
categories: cpp
thumbnail:  heart
tags:
 - 欢迎来我的博客
---

##MFC的作业
- 用规定的颜色绘制正弦、余弦曲线。由菜单或对话框定颜色。
- 这个看起来如此简单的东西耗费了我半天的时间ಥ_ಥ，大部分时间用在了调一个令人无语的bug上。



首先我做了下菜单，包括一个颜色选择菜单(弹出颜色选择对话框)，一个模式选择的下拉菜单(画正弦还是画余弦)。   

做完菜单以后给它们添加消息处理函数。  

1. 颜色选择:
{% highlight c++ %}
//修改消息映射函数，添加使用颜色选择公用对话框
void CFunctioncurveView::OnInput() {	// TODO: Add your command handler code here	CFunctioncurveDoc *pDoc = GetDocument();	ASSERT_VALID(pDoc);	CColorDialog colordlg(pDoc->m_brush); 	pDoc->m_brush = RGB(255,0,0); 	if(colordlg.DoModal()== IDOK)	{		pDoc->m_brush = colordlg.GetColor();	    pDoc->m_boolNew=false;		InvalidateRect(NULL);     }}
{% endhighlight %}
2. 模式选择
{% highlight c++ %}
//这里我在Document类声明中添加了一个model变量，用它来做选择结构
void CFunctioncurveView::OnsinFunc() {	// TODO: Add your command handler code here	CFunctioncurveDoc *pDoc = GetDocument();	ASSERT_VALID(pDoc);	pDoc->model = 0;	}void CFunctioncurveView::OncosFunc() {	// TODO: Add your command handler code here	CFunctioncurveDoc *pDoc = GetDocument();	ASSERT_VALID(pDoc);	pDoc->model = 1;}
{% endhighlight %}

声明什么的我就不写了，下面是修改OnDraw()成员函数。
{% highlight c++ %}
void CFunctioncurveView::OnDraw(CDC* pDC){	CFunctioncurveDoc* pDoc = GetDocument();	ASSERT_VALID(pDoc);	const double PI=3.14159265359;	const double dbYMax=1.0;	const double dbYMin=-1.0;	const double dbXMin=0.0;	const double dbXMax=2*PI;	const int iPt = 200;	const int xOrg = 50;	const int yOrg = 350;	const int xMax = 700;	const int yMin = 20;	double dbXRatio=(xMax-xOrg)/(dbXMax-dbXMin);    double dbYRatio=(yOrg-yMin)/(dbYMax-dbYMin);    int x = xOrg;    int y = yOrg;	if(!pDoc->m_boolNew) //声明的m_boolNew是为了让新建文档为空白视图	{	    		pDC->MoveTo(x,y);	    CPen penNew,*ppenOld; 	   	penNew.CreatePen(PS_SOLID,2,pDoc->m_brush);	    ppenOld=pDC->SelectObject(&penNew); //选择画笔颜色		if(pDoc->model == 0) //判断画正弦还是余弦		{    	    for (int i =0;i <= iPt; i++)			{	  	          x = (int)(dbXRatio*(dbXMax/iPt*i-dbXMin)+xOrg);		      y = (int)(yOrg-dbYRatio*(sin(dbXMax/iPt*i)-dbYMin));		      pDC->LineTo(x,y);			}		}		else		{	        for (int i =0;i <= iPt; i++)			{	  		      x = (int)(dbXRatio*(dbXMax/iPt*i-dbXMin)+xOrg);		      y = (int)(yOrg-dbYRatio*(cos(dbXMax/iPt*i)-dbYMin));		      pDC->LineTo(x,y);			}		 		}		pDC->SelectObject(ppenOld);		penNew.DeleteObject();//用完画笔后要及时销毁，否则再次创建的时候会报错		pDC->MoveTo(xOrg,yOrg);		pDC->LineTo(xMax,yOrg);		pDC->MoveTo(xOrg,yOrg);		pDC->LineTo(xOrg,yMin);		x=(xMax-xOrg)/2;		y=yOrg+10;        pDC->TextOut(x,y,"X");		x=xOrg-20;		y=(yOrg-yMin)/2;		pDC->TextOut(x,y,"Y");	}	else 	{		CRect rectClient;		GetClientRect(rectClient);		pDC->FillSolidRect(rectClient,RGB(255,255,255));	}	// TODO: add draw code for native data here}
{% endhighlight %}
###小结
这个题用的时间比较长的原因有有两个:第一个问题在于我错误的认为brush是pen，然后搞brush类半天什么也画不出来。还有一个问题就是我在给sin/cos创建消息映射函数的时候把成员函数的名字作死命名为sin/cos，后来将math.h包括进来的时候编译器报错,因为我重复定义了sin和cos……还是很感谢[@Lyeec](http://lyeec.me)帮我找出了问题所在(*_*)






